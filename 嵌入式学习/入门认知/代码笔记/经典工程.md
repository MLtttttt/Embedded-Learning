
# LED流水灯
```c


void delay(unsigned int n){
    unsigned int i = 0, j = 0;
    for(i = 0; i < n; i++){
        for(j = 0; j < 120; j++);
    }
}

void l_to_r(){
    unsigned char i = 0;
    for(i = 0; i < 8; i++){
        P2 = ~(0x01 << i); 
        delay(80);
    }
}

void r_to_l(){
    unsigned char i = 0;
    for(i = 0; i < 8; i++){
        P1 = (0x80 >> i);
        delay(80);
    }
}

void main(){
    while(1){
        l_to_r();
        r_to_l();
    }
}
```

# 按键控制流水灯

```c
#include "reg52.h"

sbit key = P1^0;   
sbit LED0 = P2^0;

bit direction = 0;   // 0: left->right  1: right->left
bit flag = 0;        // 0: stop flow 1: run flow

void delay(void){

}

void deb(void){
    delay(); 
}

void l_to_r(void){
    unsigned char i;
    for(i = 0; i < 8; i++){
        P2 = ~(0x01 << i);  
        delay();
        
        if(key == 0){
            deb();
            if(key == 0){
                flag = 0;       
                P2 = 0xFF;       
                while(key == 0);
                deb();
                return;       
            }
        }
    }
}

void r_to_l(void){
    unsigned char i;
    for(i = 0; i < 8; i++){
        P2 = ~(0x80 >> i);   
        delay();
        
        if(key == 0){
            deb();
            if(key == 0){
                flag = 0;
                P2 = 0xFF;
                while(key == 0);
                deb();
                return;
            }
        }
    }
}

void main(){
    P2 = 0xFF;   
    
    while(1){
     
        if(key == 0){
            deb();
            if(key == 0){
                if(flag == 0){
                    flag = 1;
                    direction = ~direction; 
                }
                else{
                    flag = 0;
                    P2 = 0xFF;
                }
                while(key == 0);  
                deb();
            }
        }
  
        if(flag == 1){
            if(direction == 0){
                l_to_r(); 
            }
            else{
                r_to_l();
            }
        }
    }
}
```

## 数码管静态显示

```c
#include "reg51.h"
#include <intrins.h>

unsigned char s[] = {0x3F, 0x06, 0x5B, 0x4F, 0x66, 0x6D, 0x7D, 0x07, 0x7F, 0x6F};

void Delay(void) {
    unsigned char data i, j, k;
    _nop_();
    _nop_();
    i = 22;
    j = 3;
    k = 227;
    do {nn
        do {
            while (--k);
        } while (--j);
    } while (--i);
}

void seg(void) {
    unsigned int i;
    for (i = 0; i < 10; i++) {
        P2 = s[i];
        Delay();
    }
}

void main(void) {
    while (1) {
        seg();
    }
}
```

## 数码管动态显示

```c
#include "reg51.h"
#include <intrins.h>

unsigned char s[] = {0x3F, 0x06, 0x5B, 0x4F, 0x66, 0x6D, 0x7D, 0x07, 0x7F, 0x6F};
unsigned char str[] = {0x76, 0x79, 0x38, 0x38, 0x3F};
unsigned char wei[] = {0x00,0x01, 0x02, 0x03, 0x04, 0x05,0x06,0x07};

void Delay(void)	//@11.0592MHz
{
	unsigned char data i, j;

	_nop_();
	_nop_();
	_nop_();
	i = 11;
	j = 190;
	do
	{
		while (--j);
	} while (--i);
}

void seg(void) {
    unsigned int i;
    for (i = 0; i < 5; i++) {
      P3=wei[i];
			P2 = str[i];
        Delay();
    }
}

void main(void) {
    while (1) {
        seg();
    }
}
```

## 按压 16 个键分别显示 0-F

  - **行线**：P1.4 ~ P1.7（高4位）
  - **列线**：P1.0 ~ P1.3（低4位）

### 行列扫描法

1. **逐列拉低**：每次只将一列设为低电平（输出0），其余列保持高电平（输出1）。
2. **读取行线**：读取高4位（行线）的状态。行线是输入引脚，内部上拉，默认高电平。
3. **==检测按键==**：==若当前列上有按键按下，则对应行线会被拉低==，高4位中相应位变为0。
4. **确定键值**：根据当前拉低的列号（0~3）和被拉低的行号（0~3），计算出唯一键值（0~15）。

```c
#include "reg51.h"  
#include <intrins.h>  
  
unsigned char code s[] = {0x3F,0x06,0x5B,0x4F,0x66,0x6D,0x7D,0x07,0x7F,0x6F,0x77,0x7C,0x39,0x5E,0x79,0x71}; unsigned char num = 0;  
  
void delay(void) {  
    unsigned char i, j;  
    i = 108;  
    j = 145;  
    do {  
        while (--j);  
    } while (--i);  
}  
  
unsigned char scan(void) {  
    P1 = 0xFE;  
    if ((P1 & 0xF0) != 0xF0) {  
        delay();  
        if ((P1 & 0xF0) == 0xE0) return 0;  
        if ((P1 & 0xF0) == 0xD0) return 1;  
        if ((P1 & 0xF0) == 0xB0) return 2;  
        if ((P1 & 0xF0) == 0x70) return 3;  
    }  
    P1 = 0xFD;  
    if ((P1 & 0xF0) != 0xF0) {  
        delay();  
        if ((P1 & 0xF0) == 0xE0) return 4;  
        if ((P1 & 0xF0) == 0xD0) return 5;  
        if ((P1 & 0xF0) == 0xB0) return 6;  
        if ((P1 & 0xF0) == 0x70) return 7;  
    }  
    P1 = 0xFB;  
    if ((P1 & 0xF0) != 0xF0) {  
        delay();  
        if ((P1 & 0xF0) == 0xE0) return 8;  
        if ((P1 & 0xF0) == 0xD0) return 9;  
        if ((P1 & 0xF0) == 0xB0) return 10;  // A  
        if ((P1 & 0xF0) == 0x70) return 11;  // b  
    }  
  
    P1 = 0xF7;  
    if ((P1 & 0xF0) != 0xF0) {  
        delay();  
        if ((P1 & 0xF0) == 0xE0) return 12;  // C  
        if ((P1 & 0xF0) == 0xD0) return 13;  // d  
        if ((P1 & 0xF0) == 0xB0) return 14;  // E  
        if ((P1 & 0xF0) == 0x70) return 15;  // F  
    }  
  
    return 16;  
}  
  
void display(void) {  
    P2 = s[num];  
}  
  
void main(void) {  
    unsigned char key;  
    P2 = 0x00;  
    while (1) {  
        key = scan();  
        if (key < 16) {  
            num = key;  
        }        display();  
    }}
```


### 反转法

行列反转法是一种快速扫描矩阵键盘的方法，通过两次改变 I/O 口的方向，一次性获取行和列的状态，从而确定按键位置。

- **第一步（确定列）**：所有行线输出低电平，列线输入（内部上拉）。读取列线状态，若有列被拉低（变为0），则记录该列号。
    
- **第二步（确定行）**：立即切换方向，所有列线输出低电平，行线输入。读取行线状态，若有行被拉低，则记录该行号。
    
- **组合**：根据两次读取的行列号，即可唯一确定按键（键值 = 行×4 + 列）。

```c
#include "reg51.h"  
#include <intrins.h>  
  
unsigned char code s[] = {0x3F,0x06,0x5B,0x4F,0x66,0x6D,0x7D,0x07,0x7F,0x6F,0x77,0x7C,0x39,0x5E,0x79,0x71};  
unsigned char num = 0;  
  
void delay(void) {  
    unsigned char i, j;  
    i = 108;  
    j = 145;  
    do {  
        while (--j);  
    } while (--i);  
}  
  
unsigned char scan(void) {  
    unsigned char row, col, key;  
    P1 = 0xF0;  
    if ((P1 & 0xF0) != 0xF0) {  
        delay();  
  
        if ((P1 & 0xF0) != 0xF0) {  
            col = P1 & 0xF0;  
            P1 = 0x0F;  
            row = P1 & 0x0F;  
            switch(col) {  
                case 0xE0: key = 0; break;  
                case 0xD0: key = 1; break;  
                case 0xB0: key = 2; break;  
                case 0x70: key = 3; break;  
                default: return 16;  
            }            switch(row) {  
                case 0x0E: key += 0; break;  
                case 0x0D: key += 4; break;  
                case 0x0B: key += 8; break;  
                case 0x07: key += 12; break;  
                default: return 16;  
            } 
            // 计算 key = row*4 + col
                   while((P1 & 0x0F) != 0x0F);  
            return key;  
        }    }    return 16;  
}  
  
void display(void) {  
    P2 = s[num];  
}  
  
void main(void) {  
    unsigned char key;  
    P2 = 0x00;  
    while(1) {  
        key = scan();  
        if(key < 16) {  
            num = key;  
        }        display();  
    }}
```