
## 0到F数码管

共阴

```c
unsigned char code s[] = {0x3F,0x06,0x5B,0x4F,0x66,0x6D,0x7D,0x07,0x7F,0x6F,0x77,0x7C,0x39,0x5E,0x79,0x71}; 
```

共阳
```c
unsigned char code seg_co[] = 
{0xC0,0xF9,0xA4,0xB0,0x99,0x92,0x82,0xF8,0x80,0x90,0x88,0x83,0xC6,0xA1,0x86,0x8E}; 
```
## 定时器模式 1
#### 推导定时器初值计算过程（以 1ms 定时为例）

 工作原理：
- 模式 1 下，定时器由两个 8 位寄存器 **TH**（高 8 位）和 **TL**（低 8 位）组成一个 16 位计数器。
- 定时器对**机器周期**进行加 1 计数。当计数器计满（从初值加到 65535 后再加 1 变为 0）时，产生溢出中断请求（若允许中断），同时置位溢出标志。
- 机器周期与晶振频率的关系：标准 8051 内核中，一个机器周期 = 12 个振荡周期。
- 因此，机器周期频率为 fmac=fosc/12.

已知条件:
- 晶振频率  fosc = 11.0592MHz=11.0592x10e6 Hz
- 目标定时时间 T = 1ms = 10^-3 s
- 机器周期 Tmac = 12/fosc≈1.085 μs
## 推导定时器初值计算过程（以 1ms 定时为例）
###  1ms 所需的机器周期数
定时时间(T) = 机器周期数(N) × 机器周期时间（Tmac）
即N=T/Tmac=10^-3/(12/(11.0592x10^-6))=921.6


由于计数器只能进行整数计数，因此 **921.6 不是整数**，需要取整
实际应用中可以取 **922** 或 **921**，两者都会引入一定的定时误差。

###  计算定时器初值(922 为例)

X + N = 65536  ⇒  X = 65536 - N
\]
代入 \( N = 922 \)  X = 65536 - 922 = 64614

### 将初值分解为 TH 和 TL
16 位初值 \( X \) 的高 8 位存入 TH，低 8 位存入 TL：
- 高 8 位：(TH =  X / 256  = 64614 / 256 = 252 )（十六进制：( 0xFC )）
- **低 8 位**：( TL = X mod 256 = 64614 - 252*256 = 64614 - 64512 = 102 （十六进制：(0x66)）

验证：252*256 + 102 = 64512 + 102 = 64614 ，正确。

因此，初值设置为：TH = 0xFC, TL = 0x66


若取 \( N = 921 \)，则：
X = 65536 - 921 = 64615
TH= 252(0xFC) TL = 103 (0x67)

### 定时误差分析
- 若取 \( N = 922 \)，实际定时时间(Treal)：
  Treal = N*Tmac = 922 x(12/11.0592*e6)≈922x1.085μs=1000.37μs
  误差约+0.37μs，相对误差 +0.037%。
- 若取 \( N = 921 \)，实际定时时间：
  Trea = 921x1.085μs ≈ 999.285μs
  误差约 -0.715μs，相对误差  -0.072%
两种取整方式误差均很小，根据实际需要选择




